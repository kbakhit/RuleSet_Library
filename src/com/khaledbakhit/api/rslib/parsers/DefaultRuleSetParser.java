/**
 * RuleSet Library
 * Copyright (C) 2013  Khaled Bakhit
 * 
 * This file is part of RuleSet Library.
 * 
 * RuleSet Library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * RuleSet Library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with RuleSet Library.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.khaledbakhit.api.rslib.parsers;

import com.khaledbakhit.api.rslib.interfaces.Parser;
import com.khaledbakhit.api.rslib.LaunchSetup;
import com.khaledbakhit.api.rslib.exceptions.InputParseException;
import com.khaledbakhit.api.rslib.exceptions.UnsupportedRuleSetFormatException;
import com.khaledbakhit.api.rslib.ruleset.DefaultRuleSetWriter;
import com.khaledbakhit.api.rslib.ruleset.Rule;
import com.khaledbakhit.api.rslib.ruleset.RuleSet;
import java.io.IOException;
import java.io.InputStream;
import java.util.LinkedList;
import java.util.Scanner;

/**
 * Default library's implementation of the RuleSetParser abstract class.<br/>
 * 
 * It can parse outputs generated by {@link DefaultRuleSetWriter} class instance.
 * @author Khaled Bakhit
 * @since 4.0
 * @version 18/08/2013
 */
public class DefaultRuleSetParser extends RuleSetParser
{
     /**
     * Scanner Object to read input classification file.
     */
    private Scanner scan;
    /**
     * List containing parsed data.
     */
    private LinkedList<RuleSet> parsedData;

    /**
     * DefaultRuleSetParser constructor.
     * @param sp LaunchSetup Object containing input configuration.
     */
    public DefaultRuleSetParser(LaunchSetup sp)
    {
        super(sp);
    }
    @Override
    public void parse(InputStream inputstream) throws InputParseException {
        try {//File or Folder?
            if (parsedData == null) {
                parsedData = new LinkedList<RuleSet>();
            } else {
                parsedData.clear();
            }

            final String RULESETS_DELIMITER = "------------------";
            scan = new Scanner(inputstream);
            scan.useDelimiter(RULESETS_DELIMITER);

            String RuleSet_Block;
            while (scan.hasNext())
            {
                RuleSet_Block = scan.next().trim();
                if (RuleSet_Block.length() == 0)
                    continue;
                
                parsedData.add(extractRuleSet(RuleSet_Block));
            }
        } 
        catch (Exception e) 
        {
            throw new InputParseException(e.getMessage());
        }

    }

    @Override
    public LinkedList<RuleSet> getParsedData() {
        return parsedData;
    }

    /**
     * Extract RuleSet from a given body paragraph.
     *
     * @param paragraph String containing definition for a RuleSet.
     * @return RuleSet object.
     * @throws UnsupportedRuleSetFormatException RuleSet paragraph format is
     * unsupported.
     */
    private RuleSet extractRuleSet(String paragraph) throws UnsupportedRuleSetFormatException {
        try 
        {
            RuleSet rs = new RuleSet(null, sp);
            Rule rule;
            String temp, temp2, temp3, Class, Default;

            Scanner default_search = new Scanner(paragraph);
            default_search.useDelimiter("Default class:");

            Scanner s = new Scanner(default_search.next());

            Default = default_search.next();
            rs.setDefaultCond(Default.trim());
            default_search.close();
            
            Scanner dscan, slscan, spscan, scan2;
            s.useDelimiter("Rule");
            s.next();        // Skipping Intro.

            while (s.hasNext()) 
            {
                temp = s.next();
                dscan = new Scanner(temp);
                dscan.useDelimiter(":");
                dscan.next();
                temp = dscan.next();
                dscan.close();
                slscan = new Scanner(temp);
                slscan.useDelimiter("->");
                temp2 = slscan.next();  // body containing conditions!
                Class = slscan.next();  // part containg class if body true!
                slscan.close();
                
                scan2 = new Scanner(Class);
                scan2.useDelimiter(" ");
                scan2.next();
                scan2.next();
                rule = new Rule(scan2.next().trim(), sp);  //added classification
                scan2.close();
                
                scan2 = new Scanner(temp2.trim());

                while (scan2.hasNextLine()) //!
                {
                    temp3 = scan2.nextLine().trim();  //!
                    spscan = new Scanner(temp3);
                    spscan.useDelimiter(" ");
                    rule.addCondition(spscan.next(), spscan.next(), spscan.next());
                    spscan.close();
                }
                scan2.close();
                rs.addRule(rule);
            }
            s.close();
            return rs;
        } 
        catch (Exception e) 
        {
            throw new UnsupportedRuleSetFormatException("Unsupported RuleSet format.");
        }
    }

    @Override
    public Parser<LinkedList<RuleSet>> newInstance() 
    {
        return new DefaultRuleSetParser(sp);
    }
    @Override
    public void close() throws IOException 
    {
        if(scan!=null)
            scan.close();
    }
}
